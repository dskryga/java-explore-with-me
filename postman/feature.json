{
	"info": {
		"_postman_id": "66ab3c3b-d22e-4cc9-87aa-028fc56e2cc0",
		"name": "Feature Comments - TESTS",
		"description": "Тесты для функциональности комментариев",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "14585162"
	},
	"item": [
		{
			"name": "Добавление комментария к опубликованному событию",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"class API {",
							"    constructor(postman, verbose = false, baseUrl = pm.variables.get('baseUrl')) {",
							"        this.baseUrl = baseUrl;",
							"        this.pm = postman;",
							"        this._verbose = verbose;",
							"    }",
							"",
							"    async addUser(user, verbose=null) {",
							"        return this.post('/admin/users', user, 'Ошибка при добавлении нового пользователя: ', verbose);",
							"    }",
							"",
							"    async addCategory(category, verbose=null) {",
							"        return this.post('/admin/categories', category, 'Ошибка при добавлении новой категории: ', verbose);",
							"    }",
							"",
							"    async addEvent(userId, event, verbose=null) {",
							"        return this.post('/users/' + userId + '/events', event, 'Ошибка при добавлении нового события: ', verbose);",
							"    }",
							"",
							"    async publishEvent(eventId, verbose=null) {",
							"        return this.patch('/admin/events/' + eventId, {stateAction: 'PUBLISH_EVENT'}, 'Ошибка при публикации события', verbose);",
							"    }",
							"    ",
							"    async addComment(userId, eventId, comment, verbose=null) {",
							"        return this.post('/users/' + userId + '/comments/' + eventId, comment, 'Ошибка при добавлении комментария: ', verbose);",
							"    }",
							"",
							"    async post(path, body, errorText = 'Ошибка при выполнении post-запроса: ', verbose=null) {",
							"        return this.sendRequest('POST', path, body, errorText, verbose);",
							"    }",
							"",
							"    async patch(path, body = null, errorText = 'Ошибка при выполнении patch-запроса: ', verbose=null) {",
							"        return this.sendRequest('PATCH', path, body, errorText, verbose);",
							"    }",
							"",
							"    async sendRequest(method, path, body=null, errorText = 'Ошибка при выполнении запроса: ', verbose=null) {",
							"        return new Promise((resolve, reject) => {",
							"            verbose = verbose == null ? this._verbose : verbose;",
							"            const request = {",
							"                url: this.baseUrl + path,",
							"                method: method,",
							"                body: body == null ? '' : JSON.stringify(body),",
							"                header: { 'Content-Type': 'application/json' },",
							"            };",
							"",
							"            try {",
							"                this.pm.sendRequest(request, (error, response) => {",
							"                    if(error || (response.code >= 400 && response.code <= 599)) {",
							"                        let err = error ? error : JSON.stringify(response.json());",
							"                        reject(new Error(errorText + err));",
							"                    }",
							"                    if (response.stream.length === 0){",
							"                        resolve(null);",
							"                    }else{",
							"                        resolve(response.json());",
							"                    }",
							"                });",
							"                ",
							"            } catch(err) {",
							"                return Promise.reject(err);",
							"            }",
							"        });",
							"    }",
							"}",
							"",
							"class RandomUtils {",
							"    constructor() {}",
							"",
							"    getUser() {",
							"        return {",
							"            name: 'Test User ' + Math.floor(Math.random() * 1000),",
							"            email: 'test' + Math.floor(Math.random() * 1000) + '@example.com'",
							"        };",
							"    }",
							"",
							"    getCategory() {",
							"        return {",
							"            name: 'Category ' + Math.floor(Math.random() * 1000)",
							"        };",
							"    }",
							"",
							"    getEvent(categoryId) {",
							"        return {",
							"            annotation: 'Test event annotation',",
							"            category: categoryId,",
							"            description: 'Test event description',",
							"            eventDate: this.getFutureDateTime(),",
							"            location: {",
							"                lat: 55.7558,",
							"                lon: 37.6173,",
							"            },",
							"            paid: false,",
							"            participantLimit: 10,",
							"            requestModeration: true,",
							"            title: 'Test Event ' + Math.floor(Math.random() * 1000),",
							"        };",
							"    }",
							"",
							"    getComment() {",
							"        return {",
							"            text: 'Test comment text ' + Math.floor(Math.random() * 1000)",
							"        };",
							"    }",
							"",
							"    getFutureDateTime(hourShift = 6, minuteShift=0, yearShift=0) {",
							"        const date = new Date();",
							"        date.setHours(date.getHours() + hourShift);",
							"        return date.toISOString().replace('T', ' ').substring(0, 19);",
							"    }",
							"}",
							"",
							"",
							"const main = async () => {",
							"const api = new API(pm);",
							"const randomUtils = new RandomUtils();",
							"",
							"// Создаем пользователя",
							"const user = randomUtils.getUser();",
							"const createdUser = await api.addUser(user);",
							"",
							"// Создаем категорию",
							"const category = randomUtils.getCategory();",
							"const createdCategory = await api.addCategory(category);",
							"",
							"// Создаем событие",
							"const event = randomUtils.getEvent(createdCategory.id);",
							"const createdEvent = await api.addEvent(createdUser.id, event);",
							"",
							"// Публикуем событие",
							"const publishedEvent = await api.publishEvent(createdEvent.id);",
							"",
							"// Сохраняем данные для теста",
							"pm.variables.set('test_user_id', createdUser.id);",
							"pm.variables.set('test_event_id', publishedEvent.id);",
							"};",
							"const interval = setInterval(() => {}, 1000);",
							"",
							"setTimeout(async () => ",
							"    {",
							"        try {",
							"            await main();",
							"        } catch (e) {",
							"            console.error(e);",
							"        } finally {",
							"            clearInterval(interval);",
							"        }",
							"    },  ",
							"    100 ",
							");"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test('Status code is 201', function () {",
							"    pm.response.to.have.status(201);",
							"});",
							"",
							"pm.test('Response has comment data', function () {",
							"    const response = pm.response.json();",
							"    pm.expect(response).to.have.property('id');",
							"    pm.expect(response).to.have.property('text');",
							"    pm.expect(response).to.have.property('author');",
							"    pm.expect(response).to.have.property('eventId');",
							"    pm.expect(response).to.have.property('publishedOn');",
							"    ",
							"    // Сохраняем ID комментария для последующих тестов",
							"    pm.variables.set('test_comment_id', response.id);",
							"});"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Content-Type",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n    \"text\": \"Отличное событие! Очень понравилось.\"\n}"
				},
				"url": {
					"raw": "{{baseUrl}}/users/{{test_user_id}}/comments/{{test_event_id}}",
					"host": [
						"{{baseUrl}}"
					],
					"path": [
						"users",
						"{{test_user_id}}",
						"comments",
						"{{test_event_id}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "Добавление комментария к неопубликованному событию",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"class API {",
							"    constructor(postman, verbose = false, baseUrl = pm.variables.get('baseUrl')) {",
							"        this.baseUrl = baseUrl;",
							"        this.pm = postman;",
							"        this._verbose = verbose;",
							"    }",
							"",
							"    async addUser(user, verbose=null) {",
							"        return this.post('/admin/users', user, 'Ошибка при добавлении нового пользователя: ', verbose);",
							"    }",
							"",
							"    async addCategory(category, verbose=null) {",
							"        return this.post('/admin/categories', category, 'Ошибка при добавлении новой категории: ', verbose);",
							"    }",
							"",
							"    async addEvent(userId, event, verbose=null) {",
							"        return this.post('/users/' + userId + '/events', event, 'Ошибка при добавлении нового события: ', verbose);",
							"    }",
							"",
							"    async publishEvent(eventId, verbose=null) {",
							"        return this.patch('/admin/events/' + eventId, {stateAction: 'PUBLISH_EVENT'}, 'Ошибка при публикации события', verbose);",
							"    }",
							"    ",
							"    async addComment(userId, eventId, comment, verbose=null) {",
							"        return this.post('/users/' + userId + '/comments/' + eventId, comment, 'Ошибка при добавлении комментария: ', verbose);",
							"    }",
							"",
							"    async post(path, body, errorText = 'Ошибка при выполнении post-запроса: ', verbose=null) {",
							"        return this.sendRequest('POST', path, body, errorText, verbose);",
							"    }",
							"",
							"    async patch(path, body = null, errorText = 'Ошибка при выполнении patch-запроса: ', verbose=null) {",
							"        return this.sendRequest('PATCH', path, body, errorText, verbose);",
							"    }",
							"",
							"    async sendRequest(method, path, body=null, errorText = 'Ошибка при выполнении запроса: ', verbose=null) {",
							"        return new Promise((resolve, reject) => {",
							"            verbose = verbose == null ? this._verbose : verbose;",
							"            const request = {",
							"                url: this.baseUrl + path,",
							"                method: method,",
							"                body: body == null ? '' : JSON.stringify(body),",
							"                header: { 'Content-Type': 'application/json' },",
							"            };",
							"",
							"            try {",
							"                this.pm.sendRequest(request, (error, response) => {",
							"                    if(error || (response.code >= 400 && response.code <= 599)) {",
							"                        let err = error ? error : JSON.stringify(response.json());",
							"                        reject(new Error(errorText + err));",
							"                    }",
							"                    if (response.stream.length === 0){",
							"                        resolve(null);",
							"                    }else{",
							"                        resolve(response.json());",
							"                    }",
							"                });",
							"                ",
							"            } catch(err) {",
							"                return Promise.reject(err);",
							"            }",
							"        });",
							"    }",
							"}",
							"",
							"class RandomUtils {",
							"    constructor() {}",
							"",
							"    getUser() {",
							"        return {",
							"            name: 'Test User ' + Math.floor(Math.random() * 1000),",
							"            email: 'test' + Math.floor(Math.random() * 1000) + '@example.com'",
							"        };",
							"    }",
							"",
							"    getCategory() {",
							"        return {",
							"            name: 'Category ' + Math.floor(Math.random() * 1000)",
							"        };",
							"    }",
							"",
							"    getEvent(categoryId) {",
							"        return {",
							"            annotation: 'Test event annotation',",
							"            category: categoryId,",
							"            description: 'Test event description',",
							"            eventDate: this.getFutureDateTime(),",
							"            location: {",
							"                lat: 55.7558,",
							"                lon: 37.6173,",
							"            },",
							"            paid: false,",
							"            participantLimit: 10,",
							"            requestModeration: true,",
							"            title: 'Test Event ' + Math.floor(Math.random() * 1000),",
							"        };",
							"    }",
							"",
							"    getComment() {",
							"        return {",
							"            text: 'Test comment text ' + Math.floor(Math.random() * 1000)",
							"        };",
							"    }",
							"",
							"    getFutureDateTime(hourShift = 6, minuteShift=0, yearShift=0) {",
							"        const date = new Date();",
							"        date.setHours(date.getHours() + hourShift);",
							"        return date.toISOString().replace('T', ' ').substring(0, 19);",
							"    }",
							"}",
							"",
							"",
							"const main = async () => {",
							"const api = new API(pm);",
							"const randomUtils = new RandomUtils();",
							"",
							"// Создаем пользователя",
							"const user = randomUtils.getUser();",
							"const createdUser = await api.addUser(user);",
							"",
							"// Создаем категорию",
							"const category = randomUtils.getCategory();",
							"const createdCategory = await api.addCategory(category);",
							"",
							"// Создаем событие",
							"const event = randomUtils.getEvent(createdCategory.id);",
							"const createdEvent = await api.addEvent(createdUser.id, event);",
							"",
							"// Сохраняем данные для теста",
							"pm.variables.set('test_user_id', createdUser.id);",
							"pm.variables.set('test_event_id', createdEvent.id);",
							"};",
							"const interval = setInterval(() => {}, 1000);",
							"",
							"setTimeout(async () => ",
							"    {",
							"        try {",
							"            await main();",
							"        } catch (e) {",
							"            console.error(e);",
							"        } finally {",
							"            clearInterval(interval);",
							"        }",
							"    },  ",
							"    100 ",
							");"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test('Status code is 409', function () {",
							"    pm.response.to.have.status(409);",
							"});",
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Content-Type",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n    \"text\": \"Отличное событие! Очень понравилось.\"\n}"
				},
				"url": {
					"raw": "{{baseUrl}}/users/{{test_user_id}}/comments/{{test_event_id}}",
					"host": [
						"{{baseUrl}}"
					],
					"path": [
						"users",
						"{{test_user_id}}",
						"comments",
						"{{test_event_id}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "Добавление комментария с пустым text",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test('Status code is 400', function () {",
							"    pm.response.to.have.status(400);",
							"});",
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"class API {",
							"    constructor(postman, verbose = false, baseUrl = pm.variables.get('baseUrl')) {",
							"        this.baseUrl = baseUrl;",
							"        this.pm = postman;",
							"        this._verbose = verbose;",
							"    }",
							"",
							"    async addUser(user, verbose=null) {",
							"        return this.post('/admin/users', user, 'Ошибка при добавлении нового пользователя: ', verbose);",
							"    }",
							"",
							"    async addCategory(category, verbose=null) {",
							"        return this.post('/admin/categories', category, 'Ошибка при добавлении новой категории: ', verbose);",
							"    }",
							"",
							"    async addEvent(userId, event, verbose=null) {",
							"        return this.post('/users/' + userId + '/events', event, 'Ошибка при добавлении нового события: ', verbose);",
							"    }",
							"",
							"    async publishEvent(eventId, verbose=null) {",
							"        return this.patch('/admin/events/' + eventId, {stateAction: 'PUBLISH_EVENT'}, 'Ошибка при публикации события', verbose);",
							"    }",
							"    ",
							"    async addComment(userId, eventId, comment, verbose=null) {",
							"        return this.post('/users/' + userId + '/comments/' + eventId, comment, 'Ошибка при добавлении комментария: ', verbose);",
							"    }",
							"",
							"    async post(path, body, errorText = 'Ошибка при выполнении post-запроса: ', verbose=null) {",
							"        return this.sendRequest('POST', path, body, errorText, verbose);",
							"    }",
							"",
							"    async patch(path, body = null, errorText = 'Ошибка при выполнении patch-запроса: ', verbose=null) {",
							"        return this.sendRequest('PATCH', path, body, errorText, verbose);",
							"    }",
							"",
							"    async sendRequest(method, path, body=null, errorText = 'Ошибка при выполнении запроса: ', verbose=null) {",
							"        return new Promise((resolve, reject) => {",
							"            verbose = verbose == null ? this._verbose : verbose;",
							"            const request = {",
							"                url: this.baseUrl + path,",
							"                method: method,",
							"                body: body == null ? '' : JSON.stringify(body),",
							"                header: { 'Content-Type': 'application/json' },",
							"            };",
							"",
							"            try {",
							"                this.pm.sendRequest(request, (error, response) => {",
							"                    if(error || (response.code >= 400 && response.code <= 599)) {",
							"                        let err = error ? error : JSON.stringify(response.json());",
							"                        reject(new Error(errorText + err));",
							"                    }",
							"                    if (response.stream.length === 0){",
							"                        resolve(null);",
							"                    }else{",
							"                        resolve(response.json());",
							"                    }",
							"                });",
							"                ",
							"            } catch(err) {",
							"                return Promise.reject(err);",
							"            }",
							"        });",
							"    }",
							"}",
							"",
							"class RandomUtils {",
							"    constructor() {}",
							"",
							"    getUser() {",
							"        return {",
							"            name: 'Test User ' + Math.floor(Math.random() * 1000),",
							"            email: 'test' + Math.floor(Math.random() * 1000) + '@example.com'",
							"        };",
							"    }",
							"",
							"    getCategory() {",
							"        return {",
							"            name: 'Category ' + Math.floor(Math.random() * 1000)",
							"        };",
							"    }",
							"",
							"    getEvent(categoryId) {",
							"        return {",
							"            annotation: 'Test event annotation',",
							"            category: categoryId,",
							"            description: 'Test event description',",
							"            eventDate: this.getFutureDateTime(),",
							"            location: {",
							"                lat: 55.7558,",
							"                lon: 37.6173,",
							"            },",
							"            paid: false,",
							"            participantLimit: 10,",
							"            requestModeration: true,",
							"            title: 'Test Event ' + Math.floor(Math.random() * 1000),",
							"        };",
							"    }",
							"",
							"    getComment() {",
							"        return {",
							"            text: 'Test comment text ' + Math.floor(Math.random() * 1000)",
							"        };",
							"    }",
							"",
							"    getFutureDateTime(hourShift = 6, minuteShift=0, yearShift=0) {",
							"        const date = new Date();",
							"        date.setHours(date.getHours() + hourShift);",
							"        return date.toISOString().replace('T', ' ').substring(0, 19);",
							"    }",
							"}",
							"const main = async () => {",
							"const api = new API(pm);",
							"const randomUtils = new RandomUtils();",
							"",
							"// Создаем пользователя",
							"const user = randomUtils.getUser();",
							"const createdUser = await api.addUser(user);",
							"",
							"// Создаем категорию",
							"const category = randomUtils.getCategory();",
							"const createdCategory = await api.addCategory(category);",
							"",
							"// Создаем событие",
							"const event = randomUtils.getEvent(createdCategory.id);",
							"const createdEvent = await api.addEvent(createdUser.id, event);",
							"",
							"// Публикуем событие",
							"const publishedEvent = await api.publishEvent(createdEvent.id);",
							"",
							"// Сохраняем данные для теста",
							"pm.variables.set('test_user_id', createdUser.id);",
							"pm.variables.set('test_event_id', publishedEvent.id);",
							"};",
							"const interval = setInterval(() => {}, 1000);",
							"",
							"setTimeout(async () => ",
							"    {",
							"        try {",
							"            await main();",
							"        } catch (e) {",
							"            console.error(e);",
							"        } finally {",
							"            clearInterval(interval);",
							"        }",
							"    },  ",
							"    100 ",
							");"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Content-Type",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n    \"text\": \"\"\n}"
				},
				"url": {
					"raw": "{{baseUrl}}/users/{{test_user_id}}/comments/{{test_event_id}}",
					"host": [
						"{{baseUrl}}"
					],
					"path": [
						"users",
						"{{test_user_id}}",
						"comments",
						"{{test_event_id}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "Просмотр списка комментариев к событию",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"class API {",
							"    constructor(postman, verbose = false, baseUrl = pm.variables.get('baseUrl')) {",
							"        this.baseUrl = baseUrl;",
							"        this.pm = postman;",
							"        this._verbose = verbose;",
							"    }",
							"",
							"    async addUser(user, verbose=null) {",
							"        return this.post('/admin/users', user, 'Ошибка при добавлении нового пользователя: ', verbose);",
							"    }",
							"",
							"    async addCategory(category, verbose=null) {",
							"        return this.post('/admin/categories', category, 'Ошибка при добавлении новой категории: ', verbose);",
							"    }",
							"",
							"    async addEvent(userId, event, verbose=null) {",
							"        return this.post('/users/' + userId + '/events', event, 'Ошибка при добавлении нового события: ', verbose);",
							"    }",
							"",
							"    async publishEvent(eventId, verbose=null) {",
							"        return this.patch('/admin/events/' + eventId, {stateAction: 'PUBLISH_EVENT'}, 'Ошибка при публикации события', verbose);",
							"    }",
							"    ",
							"    async addComment(userId, eventId, comment, verbose=null) {",
							"        return this.post('/users/' + userId + '/comments/' + eventId, comment, 'Ошибка при добавлении комментария: ', verbose);",
							"    }",
							"",
							"    async getComments(userId, eventId, from = 0, size = 10, verbose=null) {",
							"        return this.get('/users/' + userId + '/comments/' + eventId + '?from=' + from + '&size=' + size, null, 'Ошибка при получении комментариев: ', verbose);",
							"    }",
							"",
							"    async post(path, body, errorText = 'Ошибка при выполнении post-запроса: ', verbose=null) {",
							"        return this.sendRequest('POST', path, body, errorText, verbose);",
							"    }",
							"",
							"    async patch(path, body = null, errorText = 'Ошибка при выполнении patch-запроса: ', verbose=null) {",
							"        return this.sendRequest('PATCH', path, body, errorText, verbose);",
							"    }",
							"",
							"    async get(path, body = null, errorText = 'Ошибка при выполнении get-запроса: ', verbose=null) {",
							"        return this.sendRequest('GET', path, body, errorText, verbose);",
							"    }",
							"",
							"    async sendRequest(method, path, body=null, errorText = 'Ошибка при выполнении запроса: ', verbose=null) {",
							"        return new Promise((resolve, reject) => {",
							"            verbose = verbose == null ? this._verbose : verbose;",
							"            const request = {",
							"                url: this.baseUrl + path,",
							"                method: method,",
							"                body: body == null ? '' : JSON.stringify(body),",
							"                header: { 'Content-Type': 'application/json' },",
							"            };",
							"",
							"            try {",
							"                this.pm.sendRequest(request, (error, response) => {",
							"                    if(error || (response.code >= 400 && response.code <= 599)) {",
							"                        let err = error ? error : JSON.stringify(response.json());",
							"                        reject(new Error(errorText + err));",
							"                    }",
							"                    if (response.stream.length === 0){",
							"                        resolve(null);",
							"                    }else{",
							"                        resolve(response.json());",
							"                    }",
							"                });",
							"                ",
							"            } catch(err) {",
							"                return Promise.reject(err);",
							"            }",
							"        });",
							"    }",
							"}",
							"",
							"class RandomUtils {",
							"    constructor() {}",
							"",
							"    getUser() {",
							"        return {",
							"            name: 'Test User ' + Math.floor(Math.random() * 1000),",
							"            email: 'test' + Math.floor(Math.random() * 1000) + '@example.com'",
							"        };",
							"    }",
							"",
							"    getCategory() {",
							"        return {",
							"            name: 'Category ' + Math.floor(Math.random() * 1000)",
							"        };",
							"    }",
							"",
							"    getEvent(categoryId) {",
							"        return {",
							"            annotation: 'Test event annotation',",
							"            category: categoryId,",
							"            description: 'Test event description',",
							"            eventDate: this.getFutureDateTime(),",
							"            location: {",
							"                lat: 55.7558,",
							"                lon: 37.6173,",
							"            },",
							"            paid: false,",
							"            participantLimit: 10,",
							"            requestModeration: true,",
							"            title: 'Test Event ' + Math.floor(Math.random() * 1000),",
							"        };",
							"    }",
							"",
							"    getComment() {",
							"        return {",
							"            text: 'Test comment text ' + Math.floor(Math.random() * 1000)",
							"        };",
							"    }",
							"",
							"    getFutureDateTime(hourShift = 6, minuteShift=0, yearShift=0) {",
							"        const date = new Date();",
							"        date.setHours(date.getHours() + hourShift);",
							"        return date.toISOString().replace('T', ' ').substring(0, 19);",
							"    }",
							"}",
							"",
							"const main = async () => {",
							"const api = new API(pm);",
							"const randomUtils = new RandomUtils();",
							"",
							"// Создаем пользователя",
							"const user = randomUtils.getUser();",
							"const createdUser = await api.addUser(user);",
							"",
							"// Создаем категорию",
							"const category = randomUtils.getCategory();",
							"const createdCategory = await api.addCategory(category);",
							"",
							"// Создаем событие",
							"const event = randomUtils.getEvent(createdCategory.id);",
							"const createdEvent = await api.addEvent(createdUser.id, event);",
							"",
							"// Публикуем событие",
							"const publishedEvent = await api.publishEvent(createdEvent.id);",
							"",
							"// Создаем комментарий",
							"const comment = randomUtils.getComment();",
							"await api.addComment(createdUser.id, publishedEvent.id, comment);",
							"",
							"// Сохраняем данные для теста",
							"pm.variables.set('test_user_id', createdUser.id);",
							"pm.variables.set('test_event_id', publishedEvent.id);",
							"};",
							"const interval = setInterval(() => {}, 1000);",
							"",
							"setTimeout(async () => ",
							"    {",
							"        try {",
							"            await main();",
							"        } catch (e) {",
							"            console.error(e);",
							"        } finally {",
							"            clearInterval(interval);",
							"        }",
							"    },  ",
							"    100 ",
							");"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test('Status code is 200', function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test('Response contains comments array', function () {",
							"    const response = pm.response.json();",
							"    pm.expect(response).to.be.an('array');",
							"    pm.expect(response.length).to.be.greaterThan(0);",
							"    ",
							"    // Проверяем сортировку по дате (от старых к новым)",
							"    if (response.length > 1) {",
							"        const firstCommentDate = new Date(response[0].publishedOn);",
							"        const secondCommentDate = new Date(response[1].publishedOn);",
							"        pm.expect(firstCommentDate.getTime()).to.be.lte(secondCommentDate.getTime());",
							"    }",
							"});"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [],
				"url": {
					"raw": "{{baseUrl}}/users/{{test_user_id}}/comments/{{test_event_id}}?from=0&size=10",
					"host": [
						"{{baseUrl}}"
					],
					"path": [
						"users",
						"{{test_user_id}}",
						"comments",
						"{{test_event_id}}"
					],
					"query": [
						{
							"key": "from",
							"value": "0"
						},
						{
							"key": "size",
							"value": "10"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "ADMIN: просмотр всех комментариев пользователя",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"class API {",
							"    constructor(postman, verbose = false, baseUrl = pm.variables.get('baseUrl')) {",
							"        this.baseUrl = baseUrl;",
							"        this.pm = postman;",
							"        this._verbose = verbose;",
							"    }",
							"",
							"    async addUser(user, verbose=null) {",
							"        return this.post('/admin/users', user, 'Ошибка при добавлении нового пользователя: ', verbose);",
							"    }",
							"",
							"    async addCategory(category, verbose=null) {",
							"        return this.post('/admin/categories', category, 'Ошибка при добавлении новой категории: ', verbose);",
							"    }",
							"",
							"    async addEvent(userId, event, verbose=null) {",
							"        return this.post('/users/' + userId + '/events', event, 'Ошибка при добавлении нового события: ', verbose);",
							"    }",
							"",
							"    async publishEvent(eventId, verbose=null) {",
							"        return this.patch('/admin/events/' + eventId, {stateAction: 'PUBLISH_EVENT'}, 'Ошибка при публикации события', verbose);",
							"    }",
							"    ",
							"    async addComment(userId, eventId, comment, verbose=null) {",
							"        return this.post('/users/' + userId + '/comments/' + eventId, comment, 'Ошибка при добавлении комментария: ', verbose);",
							"    }",
							"",
							"    async getComments(userId, eventId, from = 0, size = 10, verbose=null) {",
							"        return this.get('/users/' + userId + '/comments/' + eventId + '?from=' + from + '&size=' + size, null, 'Ошибка при получении комментариев: ', verbose);",
							"    }",
							"",
							"    async post(path, body, errorText = 'Ошибка при выполнении post-запроса: ', verbose=null) {",
							"        return this.sendRequest('POST', path, body, errorText, verbose);",
							"    }",
							"",
							"    async patch(path, body = null, errorText = 'Ошибка при выполнении patch-запроса: ', verbose=null) {",
							"        return this.sendRequest('PATCH', path, body, errorText, verbose);",
							"    }",
							"",
							"    async get(path, body = null, errorText = 'Ошибка при выполнении get-запроса: ', verbose=null) {",
							"        return this.sendRequest('GET', path, body, errorText, verbose);",
							"    }",
							"",
							"    async sendRequest(method, path, body=null, errorText = 'Ошибка при выполнении запроса: ', verbose=null) {",
							"        return new Promise((resolve, reject) => {",
							"            verbose = verbose == null ? this._verbose : verbose;",
							"            const request = {",
							"                url: this.baseUrl + path,",
							"                method: method,",
							"                body: body == null ? '' : JSON.stringify(body),",
							"                header: { 'Content-Type': 'application/json' },",
							"            };",
							"",
							"            try {",
							"                this.pm.sendRequest(request, (error, response) => {",
							"                    if(error || (response.code >= 400 && response.code <= 599)) {",
							"                        let err = error ? error : JSON.stringify(response.json());",
							"                        reject(new Error(errorText + err));",
							"                    }",
							"                    if (response.stream.length === 0){",
							"                        resolve(null);",
							"                    }else{",
							"                        resolve(response.json());",
							"                    }",
							"                });",
							"                ",
							"            } catch(err) {",
							"                return Promise.reject(err);",
							"            }",
							"        });",
							"    }",
							"}",
							"",
							"class RandomUtils {",
							"    constructor() {}",
							"",
							"    getUser() {",
							"        return {",
							"            name: 'Test User ' + Math.floor(Math.random() * 1000),",
							"            email: 'test' + Math.floor(Math.random() * 1000) + '@example.com'",
							"        };",
							"    }",
							"",
							"    getCategory() {",
							"        return {",
							"            name: 'Category ' + Math.floor(Math.random() * 1000)",
							"        };",
							"    }",
							"",
							"    getEvent(categoryId) {",
							"        return {",
							"            annotation: 'Test event annotation',",
							"            category: categoryId,",
							"            description: 'Test event description',",
							"            eventDate: this.getFutureDateTime(),",
							"            location: {",
							"                lat: 55.7558,",
							"                lon: 37.6173,",
							"            },",
							"            paid: false,",
							"            participantLimit: 10,",
							"            requestModeration: true,",
							"            title: 'Test Event ' + Math.floor(Math.random() * 1000),",
							"        };",
							"    }",
							"",
							"    getComment() {",
							"        return {",
							"            text: 'Test comment text ' + Math.floor(Math.random() * 1000)",
							"        };",
							"    }",
							"",
							"    getFutureDateTime(hourShift = 6, minuteShift=0, yearShift=0) {",
							"        const date = new Date();",
							"        date.setHours(date.getHours() + hourShift);",
							"        return date.toISOString().replace('T', ' ').substring(0, 19);",
							"    }",
							"}",
							"const main = async () => {",
							"const api = new API(pm);",
							"const randomUtils = new RandomUtils();",
							"",
							"// Создаем пользователя",
							"const user = randomUtils.getUser();",
							"const createdUser = await api.addUser(user);",
							"",
							"// Создаем категорию",
							"const category = randomUtils.getCategory();",
							"const createdCategory = await api.addCategory(category);",
							"",
							"// Создаем событие",
							"const event = randomUtils.getEvent(createdCategory.id);",
							"const createdEvent = await api.addEvent(createdUser.id, event);",
							"",
							"// Публикуем событие",
							"const publishedEvent = await api.publishEvent(createdEvent.id);",
							"",
							"// Создаем 3 комментария",
							"const comment1 = randomUtils.getComment();",
							"await api.addComment(createdUser.id, publishedEvent.id, comment1);",
							"",
							"const comment2 = randomUtils.getComment();",
							"await api.addComment(createdUser.id, publishedEvent.id, comment2);",
							"",
							"const comment3 = randomUtils.getComment();",
							"await api.addComment(createdUser.id, publishedEvent.id, comment3);",
							"",
							"// Сохраняем данные для теста",
							"pm.variables.set('test_user_id', createdUser.id);",
							"",
							"};",
							"const interval = setInterval(() => {}, 1000);",
							"",
							"setTimeout(async () => ",
							"    {",
							"        try {",
							"            await main();",
							"        } catch (e) {",
							"            console.error(e);",
							"        } finally {",
							"            clearInterval(interval);",
							"        }",
							"    },  ",
							"    100 ",
							");"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test('Status code is 200', function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test('Response contains comments array', function () {",
							"    const response = pm.response.json();",
							"    pm.expect(response).to.be.an('array');",
							"    pm.expect(response.length).to.equal(3);",
							"    ",
							"    // Проверяем сортировку по дате (от старых к новым)",
							"    if (response.length > 1) {",
							"        const firstCommentDate = new Date(response[0].publishedOn);",
							"        const secondCommentDate = new Date(response[1].publishedOn);",
							"        pm.expect(firstCommentDate.getTime()).to.be.lte(secondCommentDate.getTime());",
							"    }",
							"});",
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [],
				"url": {
					"raw": "{{baseUrl}}/admin/comments/{{test_user_id}}?from=0&size=10",
					"host": [
						"{{baseUrl}}"
					],
					"path": [
						"admin",
						"comments",
						"{{test_user_id}}"
					],
					"query": [
						{
							"key": "from",
							"value": "0"
						},
						{
							"key": "size",
							"value": "10"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "Удаление комментария автором комментаария",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"class API {",
							"    constructor(postman, verbose = false, baseUrl = pm.variables.get('baseUrl')) {",
							"        this.baseUrl = baseUrl;",
							"        this.pm = postman;",
							"        this._verbose = verbose;",
							"    }",
							"",
							"    async addUser(user, verbose=null) {",
							"        return this.post('/admin/users', user, 'Ошибка при добавлении нового пользователя: ', verbose);",
							"    }",
							"",
							"    async addCategory(category, verbose=null) {",
							"        return this.post('/admin/categories', category, 'Ошибка при добавлении новой категории: ', verbose);",
							"    }",
							"",
							"    async addEvent(userId, event, verbose=null) {",
							"        return this.post('/users/' + userId + '/events', event, 'Ошибка при добавлении нового события: ', verbose);",
							"    }",
							"",
							"    async publishEvent(eventId, verbose=null) {",
							"        return this.patch('/admin/events/' + eventId, {stateAction: 'PUBLISH_EVENT'}, 'Ошибка при публикации события', verbose);",
							"    }",
							"    ",
							"    async addComment(userId, eventId, comment, verbose=null) {",
							"        return this.post('/users/' + userId + '/comments/' + eventId, comment, 'Ошибка при добавлении комментария: ', verbose);",
							"    }",
							"",
							"    async deleteComment(userId, commentId, verbose=null) {",
							"        return this.delete('/users/' + userId + '/comments/' + commentId, null, 'Ошибка при удалении комментария: ', verbose);",
							"    }",
							"",
							"    async post(path, body, errorText = 'Ошибка при выполнении post-запроса: ', verbose=null) {",
							"        return this.sendRequest('POST', path, body, errorText, verbose);",
							"    }",
							"",
							"    async patch(path, body = null, errorText = 'Ошибка при выполнении patch-запроса: ', verbose=null) {",
							"        return this.sendRequest('PATCH', path, body, errorText, verbose);",
							"    }",
							"",
							"    async delete(path, body = null, errorText = 'Ошибка при выполнении delete-запроса: ', verbose=null) {",
							"        return this.sendRequest('DELETE', path, body, errorText, verbose);",
							"    }",
							"",
							"    async sendRequest(method, path, body=null, errorText = 'Ошибка при выполнении запроса: ', verbose=null) {",
							"        return new Promise((resolve, reject) => {",
							"            verbose = verbose == null ? this._verbose : verbose;",
							"            const request = {",
							"                url: this.baseUrl + path,",
							"                method: method,",
							"                body: body == null ? '' : JSON.stringify(body),",
							"                header: { 'Content-Type': 'application/json' },",
							"            };",
							"",
							"            try {",
							"                this.pm.sendRequest(request, (error, response) => {",
							"                    if(error || (response.code >= 400 && response.code <= 599)) {",
							"                        let err = error ? error : JSON.stringify(response.json());",
							"                        reject(new Error(errorText + err));",
							"                    }",
							"                    if (response.stream.length === 0){",
							"                        resolve(null);",
							"                    }else{",
							"                        resolve(response.json());",
							"                    }",
							"                });",
							"                ",
							"            } catch(err) {",
							"                return Promise.reject(err);",
							"            }",
							"        });",
							"    }",
							"}",
							"",
							"class RandomUtils {",
							"    constructor() {}",
							"",
							"    getUser() {",
							"        return {",
							"            name: 'Test User ' + Math.floor(Math.random() * 1000),",
							"            email: 'test' + Math.floor(Math.random() * 1000) + '@example.com'",
							"        };",
							"    }",
							"",
							"    getCategory() {",
							"        return {",
							"            name: 'Category ' + Math.floor(Math.random() * 1000)",
							"        };",
							"    }",
							"",
							"    getEvent(categoryId) {",
							"        return {",
							"            annotation: 'Test event annotation',",
							"            category: categoryId,",
							"            description: 'Test event description',",
							"            eventDate: this.getFutureDateTime(),",
							"            location: {",
							"                lat: 55.7558,",
							"                lon: 37.6173,",
							"            },",
							"            paid: false,",
							"            participantLimit: 10,",
							"            requestModeration: true,",
							"            title: 'Test Event ' + Math.floor(Math.random() * 1000),",
							"        };",
							"    }",
							"",
							"    getComment() {",
							"        return {",
							"            text: 'Test comment text ' + Math.floor(Math.random() * 1000)",
							"        };",
							"    }",
							"",
							"    getFutureDateTime(hourShift = 6, minuteShift=0, yearShift=0) {",
							"        const date = new Date();",
							"        date.setHours(date.getHours() + hourShift);",
							"        return date.toISOString().replace('T', ' ').substring(0, 19);",
							"    }",
							"}",
							"const main = async () => {",
							"const api = new API(pm);",
							"const randomUtils = new RandomUtils();",
							"",
							"// Создаем пользователя",
							"const user = randomUtils.getUser();",
							"const createdUser = await api.addUser(user);",
							"",
							"// Создаем категорию",
							"const category = randomUtils.getCategory();",
							"const createdCategory = await api.addCategory(category);",
							"",
							"// Создаем событие",
							"const event = randomUtils.getEvent(createdCategory.id);",
							"const createdEvent = await api.addEvent(createdUser.id, event);",
							"",
							"// Публикуем событие",
							"const publishedEvent = await api.publishEvent(createdEvent.id);",
							"",
							"// Создаем комментарий",
							"const comment = randomUtils.getComment();",
							"const createdComment = await api.addComment(createdUser.id, publishedEvent.id, comment);",
							"",
							"// Сохраняем данные для теста",
							"pm.variables.set('test_user_id', createdUser.id);",
							"pm.variables.set('test_comment_id', createdComment.id);",
							"};const interval = setInterval(() => {}, 1000);",
							"",
							"setTimeout(async () => ",
							"    {",
							"        try {",
							"            await main();",
							"        } catch (e) {",
							"            console.error(e);",
							"        } finally {",
							"            clearInterval(interval);",
							"        }",
							"    },  ",
							"    100 ",
							");"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test('Status code is 204', function () {",
							"    pm.response.to.have.status(204);",
							"});"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "DELETE",
				"header": [],
				"url": {
					"raw": "{{baseUrl}}/users/{{test_user_id}}/comments/{{test_comment_id}}",
					"host": [
						"{{baseUrl}}"
					],
					"path": [
						"users",
						"{{test_user_id}}",
						"comments",
						"{{test_comment_id}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "ADMIN: Удаление комментария администратором",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"class API {",
							"    constructor(postman, verbose = false, baseUrl = pm.variables.get('baseUrl')) {",
							"        this.baseUrl = baseUrl;",
							"        this.pm = postman;",
							"        this._verbose = verbose;",
							"    }",
							"",
							"    async addUser(user, verbose=null) {",
							"        return this.post('/admin/users', user, 'Ошибка при добавлении нового пользователя: ', verbose);",
							"    }",
							"",
							"    async addCategory(category, verbose=null) {",
							"        return this.post('/admin/categories', category, 'Ошибка при добавлении новой категории: ', verbose);",
							"    }",
							"",
							"    async addEvent(userId, event, verbose=null) {",
							"        return this.post('/users/' + userId + '/events', event, 'Ошибка при добавлении нового события: ', verbose);",
							"    }",
							"",
							"    async publishEvent(eventId, verbose=null) {",
							"        return this.patch('/admin/events/' + eventId, {stateAction: 'PUBLISH_EVENT'}, 'Ошибка при публикации события', verbose);",
							"    }",
							"    ",
							"    async addComment(userId, eventId, comment, verbose=null) {",
							"        return this.post('/users/' + userId + '/comments/' + eventId, comment, 'Ошибка при добавлении комментария: ', verbose);",
							"    }",
							"",
							"    async deleteComment(userId, commentId, verbose=null) {",
							"        return this.delete('/users/' + userId + '/comments/' + commentId, null, 'Ошибка при удалении комментария: ', verbose);",
							"    }",
							"",
							"    async post(path, body, errorText = 'Ошибка при выполнении post-запроса: ', verbose=null) {",
							"        return this.sendRequest('POST', path, body, errorText, verbose);",
							"    }",
							"",
							"    async patch(path, body = null, errorText = 'Ошибка при выполнении patch-запроса: ', verbose=null) {",
							"        return this.sendRequest('PATCH', path, body, errorText, verbose);",
							"    }",
							"",
							"    async delete(path, body = null, errorText = 'Ошибка при выполнении delete-запроса: ', verbose=null) {",
							"        return this.sendRequest('DELETE', path, body, errorText, verbose);",
							"    }",
							"",
							"    async sendRequest(method, path, body=null, errorText = 'Ошибка при выполнении запроса: ', verbose=null) {",
							"        return new Promise((resolve, reject) => {",
							"            verbose = verbose == null ? this._verbose : verbose;",
							"            const request = {",
							"                url: this.baseUrl + path,",
							"                method: method,",
							"                body: body == null ? '' : JSON.stringify(body),",
							"                header: { 'Content-Type': 'application/json' },",
							"            };",
							"",
							"            try {",
							"                this.pm.sendRequest(request, (error, response) => {",
							"                    if(error || (response.code >= 400 && response.code <= 599)) {",
							"                        let err = error ? error : JSON.stringify(response.json());",
							"                        reject(new Error(errorText + err));",
							"                    }",
							"                    if (response.stream.length === 0){",
							"                        resolve(null);",
							"                    }else{",
							"                        resolve(response.json());",
							"                    }",
							"                });",
							"                ",
							"            } catch(err) {",
							"                return Promise.reject(err);",
							"            }",
							"        });",
							"    }",
							"}",
							"",
							"class RandomUtils {",
							"    constructor() {}",
							"",
							"    getUser() {",
							"        return {",
							"            name: 'Test User ' + Math.floor(Math.random() * 1000),",
							"            email: 'test' + Math.floor(Math.random() * 1000) + '@example.com'",
							"        };",
							"    }",
							"",
							"    getCategory() {",
							"        return {",
							"            name: 'Category ' + Math.floor(Math.random() * 1000)",
							"        };",
							"    }",
							"",
							"    getEvent(categoryId) {",
							"        return {",
							"            annotation: 'Test event annotation',",
							"            category: categoryId,",
							"            description: 'Test event description',",
							"            eventDate: this.getFutureDateTime(),",
							"            location: {",
							"                lat: 55.7558,",
							"                lon: 37.6173,",
							"            },",
							"            paid: false,",
							"            participantLimit: 10,",
							"            requestModeration: true,",
							"            title: 'Test Event ' + Math.floor(Math.random() * 1000),",
							"        };",
							"    }",
							"",
							"    getComment() {",
							"        return {",
							"            text: 'Test comment text ' + Math.floor(Math.random() * 1000)",
							"        };",
							"    }",
							"",
							"    getFutureDateTime(hourShift = 6, minuteShift=0, yearShift=0) {",
							"        const date = new Date();",
							"        date.setHours(date.getHours() + hourShift);",
							"        return date.toISOString().replace('T', ' ').substring(0, 19);",
							"    }",
							"}",
							"const main = async () => {",
							"const api = new API(pm);",
							"const randomUtils = new RandomUtils();",
							"",
							"// Создаем пользователя",
							"const user = randomUtils.getUser();",
							"const createdUser = await api.addUser(user);",
							"",
							"// Создаем категорию",
							"const category = randomUtils.getCategory();",
							"const createdCategory = await api.addCategory(category);",
							"",
							"// Создаем событие",
							"const event = randomUtils.getEvent(createdCategory.id);",
							"const createdEvent = await api.addEvent(createdUser.id, event);",
							"",
							"// Публикуем событие",
							"const publishedEvent = await api.publishEvent(createdEvent.id);",
							"",
							"// Создаем комментарий",
							"const comment = randomUtils.getComment();",
							"const createdComment = await api.addComment(createdUser.id, publishedEvent.id, comment);",
							"",
							"// Сохраняем данные для теста",
							"pm.variables.set('test_user_id', createdUser.id);",
							"pm.variables.set('test_comment_id', createdComment.id);",
							"};",
							"const interval = setInterval(() => {}, 1000);",
							"",
							"setTimeout(async () => ",
							"    {",
							"        try {",
							"            await main();",
							"        } catch (e) {",
							"            console.error(e);",
							"        } finally {",
							"            clearInterval(interval);",
							"        }",
							"    },  ",
							"    100 ",
							");"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test('Status code is 204', function () {",
							"    pm.response.to.have.status(204);",
							"});"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "DELETE",
				"header": [],
				"url": {
					"raw": "{{baseUrl}}/admin/comments/{{test_comment_id}}",
					"host": [
						"{{baseUrl}}"
					],
					"path": [
						"admin",
						"comments",
						"{{test_comment_id}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "Удаление комментария автором события",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"class API {",
							"    constructor(postman, verbose = false, baseUrl = pm.variables.get('baseUrl')) {",
							"        this.baseUrl = baseUrl;",
							"        this.pm = postman;",
							"        this._verbose = verbose;",
							"    }",
							"",
							"    async addUser(user, verbose=null) {",
							"        return this.post('/admin/users', user, 'Ошибка при добавлении нового пользователя: ', verbose);",
							"    }",
							"",
							"    async addCategory(category, verbose=null) {",
							"        return this.post('/admin/categories', category, 'Ошибка при добавлении новой категории: ', verbose);",
							"    }",
							"",
							"    async addEvent(userId, event, verbose=null) {",
							"        return this.post('/users/' + userId + '/events', event, 'Ошибка при добавлении нового события: ', verbose);",
							"    }",
							"",
							"    async publishEvent(eventId, verbose=null) {",
							"        return this.patch('/admin/events/' + eventId, {stateAction: 'PUBLISH_EVENT'}, 'Ошибка при публикации события', verbose);",
							"    }",
							"    ",
							"    async addComment(userId, eventId, comment, verbose=null) {",
							"        return this.post('/users/' + userId + '/comments/' + eventId, comment, 'Ошибка при добавлении комментария: ', verbose);",
							"    }",
							"",
							"    async deleteComment(userId, commentId, verbose=null) {",
							"        return this.delete('/users/' + userId + '/comments/' + commentId, null, 'Ошибка при удалении комментария: ', verbose);",
							"    }",
							"",
							"    async post(path, body, errorText = 'Ошибка при выполнении post-запроса: ', verbose=null) {",
							"        return this.sendRequest('POST', path, body, errorText, verbose);",
							"    }",
							"",
							"    async patch(path, body = null, errorText = 'Ошибка при выполнении patch-запроса: ', verbose=null) {",
							"        return this.sendRequest('PATCH', path, body, errorText, verbose);",
							"    }",
							"",
							"    async delete(path, body = null, errorText = 'Ошибка при выполнении delete-запроса: ', verbose=null) {",
							"        return this.sendRequest('DELETE', path, body, errorText, verbose);",
							"    }",
							"",
							"    async sendRequest(method, path, body=null, errorText = 'Ошибка при выполнении запроса: ', verbose=null) {",
							"        return new Promise((resolve, reject) => {",
							"            verbose = verbose == null ? this._verbose : verbose;",
							"            const request = {",
							"                url: this.baseUrl + path,",
							"                method: method,",
							"                body: body == null ? '' : JSON.stringify(body),",
							"                header: { 'Content-Type': 'application/json' },",
							"            };",
							"",
							"            try {",
							"                this.pm.sendRequest(request, (error, response) => {",
							"                    if(error || (response.code >= 400 && response.code <= 599)) {",
							"                        let err = error ? error : JSON.stringify(response.json());",
							"                        reject(new Error(errorText + err));",
							"                    }",
							"                    if (response.stream.length === 0){",
							"                        resolve(null);",
							"                    }else{",
							"                        resolve(response.json());",
							"                    }",
							"                });",
							"                ",
							"            } catch(err) {",
							"                return Promise.reject(err);",
							"            }",
							"        });",
							"    }",
							"}",
							"",
							"class RandomUtils {",
							"    constructor() {}",
							"",
							"    getUser() {",
							"        return {",
							"            name: 'Test User ' + Math.floor(Math.random() * 1000),",
							"            email: 'test' + Math.floor(Math.random() * 1000) + '@example.com'",
							"        };",
							"    }",
							"",
							"    getCategory() {",
							"        return {",
							"            name: 'Category ' + Math.floor(Math.random() * 1000)",
							"        };",
							"    }",
							"",
							"    getEvent(categoryId) {",
							"        return {",
							"            annotation: 'Test event annotation',",
							"            category: categoryId,",
							"            description: 'Test event description',",
							"            eventDate: this.getFutureDateTime(),",
							"            location: {",
							"                lat: 55.7558,",
							"                lon: 37.6173,",
							"            },",
							"            paid: false,",
							"            participantLimit: 10,",
							"            requestModeration: true,",
							"            title: 'Test Event ' + Math.floor(Math.random() * 1000),",
							"        };",
							"    }",
							"",
							"    getComment() {",
							"        return {",
							"            text: 'Test comment text ' + Math.floor(Math.random() * 1000)",
							"        };",
							"    }",
							"",
							"    getFutureDateTime(hourShift = 6, minuteShift=0, yearShift=0) {",
							"        const date = new Date();",
							"        date.setHours(date.getHours() + hourShift);",
							"        return date.toISOString().replace('T', ' ').substring(0, 19);",
							"    }",
							"}",
							"const main = async () => {",
							"const api = new API(pm);",
							"const randomUtils = new RandomUtils();",
							"",
							"// Создаем пользователя",
							"const user = randomUtils.getUser();",
							"const createdUser = await api.addUser(user);",
							"",
							"// Создаем категорию",
							"const category = randomUtils.getCategory();",
							"const createdCategory = await api.addCategory(category);",
							"",
							"// Создаем событие",
							"const event = randomUtils.getEvent(createdCategory.id);",
							"const createdEvent = await api.addEvent(createdUser.id, event);",
							"",
							"// Публикуем событие",
							"const publishedEvent = await api.publishEvent(createdEvent.id);",
							"",
							"//создаем пользователя-автора комментария",
							"const user2 = randomUtils.getUser();",
							"const userAuthor = await api.addUser(user2);",
							"",
							"// Создаем комментарий",
							"const comment = randomUtils.getComment();",
							"const createdComment = await api.addComment(userAuthor.id, publishedEvent.id, comment);",
							"",
							"// Сохраняем данные для теста",
							"pm.variables.set('test_user_id', userAuthor.id);",
							"pm.variables.set('test_comment_id', createdComment.id);",
							"};",
							"const interval = setInterval(() => {}, 1000);",
							"",
							"setTimeout(async () => ",
							"    {",
							"        try {",
							"            await main();",
							"        } catch (e) {",
							"            console.error(e);",
							"        } finally {",
							"            clearInterval(interval);",
							"        }",
							"    },  ",
							"    100 ",
							");"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test('Status code is 204', function () {",
							"    pm.response.to.have.status(204);",
							"});"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "DELETE",
				"header": [],
				"url": {
					"raw": "{{baseUrl}}/users/{{test_user_id}}/comments/{{test_comment_id}}",
					"host": [
						"{{baseUrl}}"
					],
					"path": [
						"users",
						"{{test_user_id}}",
						"comments",
						"{{test_comment_id}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "Удаление комментария не автором события или комментария",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"class API {",
							"    constructor(postman, verbose = false, baseUrl = pm.variables.get('baseUrl')) {",
							"        this.baseUrl = baseUrl;",
							"        this.pm = postman;",
							"        this._verbose = verbose;",
							"    }",
							"",
							"    async addUser(user, verbose=null) {",
							"        return this.post('/admin/users', user, 'Ошибка при добавлении нового пользователя: ', verbose);",
							"    }",
							"",
							"    async addCategory(category, verbose=null) {",
							"        return this.post('/admin/categories', category, 'Ошибка при добавлении новой категории: ', verbose);",
							"    }",
							"",
							"    async addEvent(userId, event, verbose=null) {",
							"        return this.post('/users/' + userId + '/events', event, 'Ошибка при добавлении нового события: ', verbose);",
							"    }",
							"",
							"    async publishEvent(eventId, verbose=null) {",
							"        return this.patch('/admin/events/' + eventId, {stateAction: 'PUBLISH_EVENT'}, 'Ошибка при публикации события', verbose);",
							"    }",
							"    ",
							"    async addComment(userId, eventId, comment, verbose=null) {",
							"        return this.post('/users/' + userId + '/comments/' + eventId, comment, 'Ошибка при добавлении комментария: ', verbose);",
							"    }",
							"",
							"    async deleteComment(userId, commentId, verbose=null) {",
							"        return this.delete('/users/' + userId + '/comments/' + commentId, null, 'Ошибка при удалении комментария: ', verbose);",
							"    }",
							"",
							"    async post(path, body, errorText = 'Ошибка при выполнении post-запроса: ', verbose=null) {",
							"        return this.sendRequest('POST', path, body, errorText, verbose);",
							"    }",
							"",
							"    async patch(path, body = null, errorText = 'Ошибка при выполнении patch-запроса: ', verbose=null) {",
							"        return this.sendRequest('PATCH', path, body, errorText, verbose);",
							"    }",
							"",
							"    async delete(path, body = null, errorText = 'Ошибка при выполнении delete-запроса: ', verbose=null) {",
							"        return this.sendRequest('DELETE', path, body, errorText, verbose);",
							"    }",
							"",
							"    async sendRequest(method, path, body=null, errorText = 'Ошибка при выполнении запроса: ', verbose=null) {",
							"        return new Promise((resolve, reject) => {",
							"            verbose = verbose == null ? this._verbose : verbose;",
							"            const request = {",
							"                url: this.baseUrl + path,",
							"                method: method,",
							"                body: body == null ? '' : JSON.stringify(body),",
							"                header: { 'Content-Type': 'application/json' },",
							"            };",
							"",
							"            try {",
							"                this.pm.sendRequest(request, (error, response) => {",
							"                    if(error || (response.code >= 400 && response.code <= 599)) {",
							"                        let err = error ? error : JSON.stringify(response.json());",
							"                        reject(new Error(errorText + err));",
							"                    }",
							"                    if (response.stream.length === 0){",
							"                        resolve(null);",
							"                    }else{",
							"                        resolve(response.json());",
							"                    }",
							"                });",
							"                ",
							"            } catch(err) {",
							"                return Promise.reject(err);",
							"            }",
							"        });",
							"    }",
							"}",
							"",
							"class RandomUtils {",
							"    constructor() {}",
							"",
							"    getUser() {",
							"        return {",
							"            name: 'Test User ' + Math.floor(Math.random() * 1000),",
							"            email: 'test' + Math.floor(Math.random() * 1000) + '@example.com'",
							"        };",
							"    }",
							"",
							"    getCategory() {",
							"        return {",
							"            name: 'Category ' + Math.floor(Math.random() * 1000)",
							"        };",
							"    }",
							"",
							"    getEvent(categoryId) {",
							"        return {",
							"            annotation: 'Test event annotation',",
							"            category: categoryId,",
							"            description: 'Test event description',",
							"            eventDate: this.getFutureDateTime(),",
							"            location: {",
							"                lat: 55.7558,",
							"                lon: 37.6173,",
							"            },",
							"            paid: false,",
							"            participantLimit: 10,",
							"            requestModeration: true,",
							"            title: 'Test Event ' + Math.floor(Math.random() * 1000),",
							"        };",
							"    }",
							"",
							"    getComment() {",
							"        return {",
							"            text: 'Test comment text ' + Math.floor(Math.random() * 1000)",
							"        };",
							"    }",
							"",
							"    getFutureDateTime(hourShift = 6, minuteShift=0, yearShift=0) {",
							"        const date = new Date();",
							"        date.setHours(date.getHours() + hourShift);",
							"        return date.toISOString().replace('T', ' ').substring(0, 19);",
							"    }",
							"}",
							"const main = async () => {",
							"const api = new API(pm);",
							"const randomUtils = new RandomUtils();",
							"",
							"// Создаем пользователя",
							"const user = randomUtils.getUser();",
							"const createdUser = await api.addUser(user);",
							"",
							"const user2 = randomUtils.getUser();",
							"const anotherUser = await api.addUser(user2);",
							"",
							"// Создаем категорию",
							"const category = randomUtils.getCategory();",
							"const createdCategory = await api.addCategory(category);",
							"",
							"// Создаем событие",
							"const event = randomUtils.getEvent(createdCategory.id);",
							"const createdEvent = await api.addEvent(createdUser.id, event);",
							"",
							"// Публикуем событие",
							"const publishedEvent = await api.publishEvent(createdEvent.id);",
							"",
							"// Создаем комментарий",
							"const comment = randomUtils.getComment();",
							"const createdComment = await api.addComment(createdUser.id, publishedEvent.id, comment);",
							"",
							"// Сохраняем данные для теста",
							"pm.variables.set('test_user_id', anotherUser.id);",
							"pm.variables.set('test_comment_id', createdComment.id);",
							"};",
							"const interval = setInterval(() => {}, 1000);",
							"",
							"setTimeout(async () => ",
							"    {",
							"        try {",
							"            await main();",
							"        } catch (e) {",
							"            console.error(e);",
							"        } finally {",
							"            clearInterval(interval);",
							"        }",
							"    },  ",
							"    100 ",
							");"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test('Status code is 409', function () {",
							"    pm.response.to.have.status(409);",
							"});"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "DELETE",
				"header": [],
				"url": {
					"raw": "{{baseUrl}}/users/{{test_user_id}}/comments/{{test_comment_id}}",
					"host": [
						"{{baseUrl}}"
					],
					"path": [
						"users",
						"{{test_user_id}}",
						"comments",
						"{{test_comment_id}}"
					]
				}
			},
			"response": []
		}
	],
	"variable": [
		{
			"key": "baseUrl",
			"value": "http://localhost:8080",
			"type": "string"
		}
	]
}